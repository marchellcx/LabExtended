using NorthwoodLib.Pools;

using System.Text;
using System.Text.RegularExpressions;

using UnityEngine;

namespace LabExtended.Extensions;

/// <summary>
/// Extensions targeting strings.
/// </summary>
public static class StringExtensions
{
    /// <summary>
    /// The character used to escape ANSI colors.
    /// </summary>
    public const char LogAnsiColorEscapeChar = (char)27;

    /// <summary>
    /// The UTF-8 encoding.
    /// </summary>
    public static UTF8Encoding Utf8 { get; } = new(false, true);

    /// <summary>
    /// Regex used to match new lines.
    /// </summary>
    public static readonly Regex NewLineRegex = new Regex("r\n|\r|\n", RegexOptions.Compiled);

    /// <summary>
    /// Regex used to match pascal case.
    /// </summary>
    public static readonly Regex PascalCaseRegex = new Regex("([a-z,0-9](?=[A-Z])|[A-Z](?=[A-Z][a-z]))", RegexOptions.Compiled);

    /// <summary>
    /// Regex used to match camel case.
    /// </summary>
    public static readonly Regex CamelCaseRegex = new Regex("([A-Z])([A-Z]+)($|[A-Z])", RegexOptions.Compiled);

    /// <summary>
    /// List of all supported ANSI colors.
    /// </summary>
    public static readonly IReadOnlyList<string> LogAnsiColors = new List<string>()
    {
        "[30m", // Black - &0
        "[31m", // Red = &1
        "[32m", // Green - &2
        "[33m", // Yellow - &3
        "[34m", // Blue - &4
        "[35m", // Purple - &5
        "[36m", // Cyan - &6
        "[37m", // White - &7

        "[0m", // Reset - &r

        "[1m", // Bold On - &b
        "[22m", // Bold Off - &B

        "[3m", // Italic On - &o
        "[23m", // Italic Off - &O

        "[4m", // Underline On - &n
        "[24m", // Underline Off - &N

        "[9m", // Strikethrough On - &m
        "[29m" // Strikethrough Off - &M
    };

    /// <summary>
    /// Gets a read-only list of string prefixes used to represent true color and text formatting codes.
    /// </summary>
    public static readonly IReadOnlyList<string> TrueColorPrefixes = new List<string>()
    {
        "&0", // Black
        "&1", // Red
        "&2", // Green
        "&3", // Yellow
        "&4", // Blue
        "&5", // Purple
        "&6", // Cyan
        "&7", // White
        "&r", // Reset
        "&b", // Bold On
        "&B", // Bold Off
        "&o", // Italic On
        "&O", // Italic Off
        "&n", // Underline On
        "&N", // Underline Off
        "&m", // Strikethrough On
        "&M"  // Strikethrough Off
    };

    /// <summary>
    /// Trims the end of all strings in an array.
    /// </summary>
    public static void TrimEnds(this string[] strings, params char[] chars)
    {
        for (int i = 0; i < strings.Length; i++)
            strings[i] = strings[i].TrimEnd(chars);
    }

    /// <summary>
    /// Trims the start of all strings in an array.
    /// </summary>
    public static void TrimStarts(this string[] strings, params char[] chars)
    {
        for (int i = 0; i < strings.Length; i++)
            strings[i] = strings[i].TrimStart(chars);
    }

    /// <summary>
    /// Trims all strings in an array.
    /// </summary>
    public static void TrimStrings(this string[] strings)
    {
        for (int i = 0; i < strings.Length; i++)
            strings[i] = strings[i].Trim();
    }

    /// <summary>
    /// Trims all strings in an array.
    /// </summary>
    public static void TrimStrings(this string[] strings, params char[] chars)
    {
        for (int i = 0; i < strings.Length; i++)
            strings[i] = strings[i].Trim(chars);
    }

    /// <summary>
    /// Removes compiler-generated artifacts and generic arity from a type or member name, returning a simplified,
    /// human-readable identifier.
    /// </summary>
    /// <remarks>This method is useful for displaying type or member names in logs, diagnostics, or user
    /// interfaces where compiler-generated details are unnecessary or confusing. It handles common patterns such as
    /// generic arity (e.g., '`1'), lambda display classes, and compiler-generated method names (e.g.,
    /// '{MethodName}b__'). For constructors and static constructors, the method returns 'constructor' or 'static
    /// constructor' respectively.</remarks>
    /// <param name="name">The name to sanitize. This may be a compiler-generated name or a generic type name.</param>
    /// <returns>A sanitized string representing the original name without compiler-generated patterns or generic arity. Returns
    /// an empty string if the input is null or empty.</returns>
    public static string SanitizeCompilerGeneratedName(this string name)
    {
        if (string.IsNullOrEmpty(name))
            return string.Empty;

        // Quick exit for normal types
        if (!name.Contains('<') && !name.Contains('`'))
            return name;

        // Remove generic arity (`1, `2 etc.)
        var backtickIndex = name.IndexOf('`');

        if (backtickIndex >= 0)
            name = name.Substring(0, backtickIndex);

        // Handle compiler generated names: <MethodName>b__, <MethodName>c__, d__ etc.
        // and lambda display classes <Main>b__0, <Main>b__0_0 etc.
        if (name.StartsWith("<"))
        {
            var closingBracket = name.IndexOf('>');

            if (closingBracket > 1)
            {
                var inner = name.Substring(1, closingBracket - 1);

                if (inner == "cctor") 
                    return "static constructor";

                if (inner == "ctor") 
                    return "constructor";

                for (var i = inner.Length - 1; i >= 0; i--)
                {
                    if (!char.IsLetter(inner[i]))
                    {
                        if (i > 0)
                            inner = inner.Substring(0, i);

                        break;
                    }
                }

                return inner;
            }
        }

        return name;
    }

    /// <summary>
    /// Removes all recognized true color escape sequence prefixes from the specified string.
    /// </summary>
    /// <remarks>This method is intended for use with strings that may contain ANSI true color escape
    /// sequences, such as those used for terminal color formatting. Only recognized prefixes defined in the internal
    /// prefix list are removed; other content is left unchanged.</remarks>
    /// <param name="str">The string to sanitize by removing true color escape sequence prefixes.</param>
    /// <returns>A new string with all true color escape sequence prefixes removed. If no such prefixes are found, the original
    /// string is returned.</returns>
    public static string SanitizeTrueColorString(this string str)
    {
        for (var x = 0; x < TrueColorPrefixes.Count; x++)
            str = str.Replace(TrueColorPrefixes[x], "");

        return str;
    }

    // https://github.com/northwood-studios/NwPluginAPI/blob/master/NwPluginAPI/Core/Log.cs
    // This function was removed in LabAPI so I'm re-adding it.
    /// <summary>
    /// Formats color-coded text to ANSI text.
    /// <para>Formatting works as follows:</para>
    /// <para>A singular letter / number that specifies the operation follows.</para>
    /// <para>0 - Black</para>
    /// <para>1 - Red</para>
    /// <para>2 - Green</para>
    /// <para>3 - Yellow</para>
    /// <para>4 - Blue</para>
    /// <para>5 - Purple</para>
    /// <para>6 - Cyan</para>
    /// <para>7 - White</para>
    /// <para>r - Resets all tags</para>
    /// <para>b / B - Bold characters on / off</para>
    /// <para>o / O - Italic characters on / off</para>
    /// <para>m / M - Strikethrough on / off</para>
    /// <para>n / N - Underlinining on / off</para>
    /// </summary>
    /// <param name="str">The message to format.</param>
    /// <param name="defaultColor">The color to use as default.</param>
    /// <param name="unityRichText">Whether or not to convert to Rich Text.</param>
    /// <param name="ignoreTrueColor">Whether or not to ignore true color tags.</param>
    /// <returns>The formatted string.</returns>
    public static string FormatTrueColorString(this string str, string? defaultColor = "7", bool unityRichText = false, bool ignoreTrueColor = false)
    {
        var isPrefix = false;
        var escapeChar = (char)27;

        var newText = string.Empty;
        var lastTag = string.Empty;

        if (defaultColor != null)
            defaultColor = FormatTrueColorString($"&{defaultColor}", null, unityRichText, ignoreTrueColor);

        string EndTag(ref string currentTag)
        {
            var saveTag = currentTag;

            currentTag = string.Empty;
            return $"</{saveTag}>";
        }

        for (var x = 0; x < str.Length; x++)
        {
            if (str[x] == '&' && !isPrefix)
            {
                isPrefix = true;
                continue;
            }

            if (isPrefix)
            {
                if (ignoreTrueColor)
                {
                    isPrefix = false;
                    continue;
                }

                switch (str[x])
                {
                    // Black
                    case '0':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=black>" : $"{escapeChar}[30m";

                        lastTag = "color";
                        break;

                    // Red
                    case '1':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=red>" : $"{escapeChar}[31m";

                        lastTag = "color";
                        break;

                    // Green
                    case '2':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=green>" : $"{escapeChar}[32m";

                        lastTag = "color";
                        break;

                    // Yellow
                    case '3':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=yellow>" : $"{escapeChar}[33m";

                        lastTag = "color";
                        break;

                    // Blue
                    case '4':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=blue>" : $"{escapeChar}[34m";

                        lastTag = "color";
                        break;

                    // Purple
                    case '5':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=purple>" : $"{escapeChar}[35m";

                        lastTag = "color";
                        break;

                    // Cyan
                    case '6':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=cyan>" : $"{escapeChar}[36m";

                        lastTag = "color";
                        break;

                    // White
                    case '7':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<color=white>" : $"{escapeChar}[37m";

                        lastTag = "color";
                        break;

                    // Reset
                    case 'r':
                        if (unityRichText && lastTag != string.Empty)
                        {
                            if (defaultColor != null)
                            {
                                newText += EndTag(ref lastTag) + $"{defaultColor}";

                                lastTag = "color";
                            }
                            else
                            {
                                EndTag(ref lastTag);
                            }

                            break;
                        }

                        if (!unityRichText)
                            newText += $"{escapeChar}[0m";
                        break;

                    // Bold on
                    case 'b':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<b>" : $"{escapeChar}[1m";
                        break;

                    // Bold off
                    case 'B':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "</b>" : $"{escapeChar}[22m";
                        break;

                    // Italic on
                    case 'o':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "<i>" : $"{escapeChar}[3m";
                        break;

                    // Italic off
                    case 'O':
                        if (unityRichText && lastTag != string.Empty)
                            newText += EndTag(ref lastTag);

                        newText += unityRichText ? "</i>" : $"{escapeChar}[23m";
                        break;

                    // Underline on
                    case 'n':
                        if (unityRichText) 
                            break;

                        newText += $"{escapeChar}[4m";
                        break;

                    // Underline off
                    case 'N':
                        if (unityRichText) 
                            break;

                        newText += $"{escapeChar}[24m";
                        break;

                    // Strikethrough on 
                    case 'm':
                        if (unityRichText) 
                            break;

                        newText += $"{escapeChar}[9m";
                        break;

                    // Strikethrough off
                    case 'M':
                        if (unityRichText) 
                            break;

                        newText += $"{escapeChar}[29m";
                        break;
                }

                isPrefix = false;
                continue;
            }

            newText += str[x];

            if (unityRichText && x == str.Length - 1 && lastTag != string.Empty)
                newText += EndTag(ref lastTag);
        }

        return newText;
    }

    /// <summary>
    /// Removes all ANSI color tags from a string.
    /// </summary>
    public static string RemoveLogAnsiColors(this string str, bool removeTags = false)
    {
        if (removeTags)
            str = str.RemoveHtmlTags();

        foreach (var color in LogAnsiColors)
            str = str.Replace($"{LogAnsiColorEscapeChar}{color}", "");

        return str;
    }

    /// <summary>
    /// Attempts to peek at an index in a string.
    /// </summary>
    public static bool TryPeekIndex(this string str, int index, out char value)
    {
        if (index >= str.Length)
        {
            value = default;
            return false;
        }

        value = str[index];
        return true;
    }

    /// <summary>
    /// Splits the string into a list by max length.
    /// </summary>
    public static List<string> SplitByLength(this string str, int maxLength)
    {
        var list = new List<string>(Mathf.CeilToInt(str.Length / maxLength));

        SplitByLength(str, maxLength, list);
        return list;
    }

    /// <summary>
    /// Splits the string into a collection by max length.
    /// </summary>
    public static void SplitByLength(this string str, int maxLength, ICollection<string> target)
    {
        if (maxLength <= 0)
            throw new ArgumentOutOfRangeException(nameof(maxLength));

        if (target is null)
            throw new ArgumentNullException(nameof(target));

        while (str.Length > maxLength)
        {
            var otherStr = str.Substring(0, maxLength);

            str = str.Remove(0, maxLength);

            target.Add(otherStr);
        }

        target.Add(str);
    }

    /// <summary>
    /// Splits the string into a collection by UTF-8 byte count.
    /// </summary>
    public static void SplitByLengthUtf8(this string str, int maxLength, ICollection<string> target)
    {
        if (maxLength <= 0)
            throw new ArgumentOutOfRangeException(nameof(maxLength));

        if (target is null)
            throw new ArgumentNullException(nameof(target));

        if (string.IsNullOrEmpty(str))
            return;

        var utf8 = Encoding.UTF8;

        var start = 0;
        var length = str.Length;

        while (start < length)
        {
            var end = start;
            var byteCount = 0;

            while (end < length)
            {
                var charSize = utf8.GetByteCount(new char[] { str[end] });

                if (byteCount + charSize > maxLength)
                    break;

                byteCount += charSize;
                end++;
            }

            var chunk = str.Substring(start, end - start);

            target.Add(chunk);

            start = end;
        }
    }

    /// <summary>
    /// Splits a string by new lines.
    /// </summary>
    public static string[] SplitLines(this string line)
        => NewLineRegex.Split(line);

    /// <summary>
    /// Whether or not a string contains HTML tags.
    /// </summary>
    public static bool HasHtmlTags(this string text, out IList<int> openIndexes, out IList<int> closeIndexes)
    {
        openIndexes = Regex.Matches(text, "<").Cast<Match>().Select(m => m.Index).ToList();
        closeIndexes = Regex.Matches(text, ">").Cast<Match>().Select(m => m.Index).ToList();

        return openIndexes.Any() || closeIndexes.Any();
    }

    /// <summary>
    /// Removes all HTML tags in a string.
    /// </summary>
    public static string RemoveHtmlTags(this string text, IList<int> openTagIndexes = null, IList<int> closeTagIndexes = null)
    {
        openTagIndexes ??= Regex.Matches(text, "<").Cast<Match>().Select(m => m.Index).ToList();
        closeTagIndexes ??= Regex.Matches(text, ">").Cast<Match>().Select(m => m.Index).ToList();

        if (closeTagIndexes.Count > 0)
        {
            var sb = StringBuilderPool.Shared.Rent();
            var previousIndex = 0;

            foreach (int closeTagIndex in closeTagIndexes)
            {
                var openTagsSubset = openTagIndexes.Where(x => x >= previousIndex && x < closeTagIndex);

                if (openTagsSubset.Count() > 0 && closeTagIndex - openTagsSubset.Max() > 1)
                    sb.Append(text.Substring(previousIndex, openTagsSubset.Max() - previousIndex));
                else
                    sb.Append(text.Substring(previousIndex, closeTagIndex - previousIndex + 1));

                previousIndex = closeTagIndex + 1;
            }

            if (closeTagIndexes.Max() < text.Length)
                sb.Append(text.Substring(closeTagIndexes.Max() + 1));

            return StringBuilderPool.Shared.ToStringReturn(sb);
        }
        else
        {
            return text;
        }
    }

    /// <summary>
    /// Removes a list of characters from a string.
    /// </summary>
    public static string Remove(this string value, IEnumerable<char> toRemove)
    {
        foreach (var c in toRemove)
            value = value.Replace($"{c}", "");

        return value;
    }

    /// <summary>
    /// Removes a list of strings from a string.
    /// </summary>
    public static string Remove(this string value, IEnumerable<string> toRemove)
    {
        foreach (var c in toRemove)
            value = value.Replace(c, "");

        return value;
    }

    /// <summary>
    /// Removes a list of characters from a string.
    /// </summary>
    public static string Remove(this string value, params char[] toRemove)
    {
        foreach (var c in toRemove)
            value = value.Replace($"{c}", "");

        return value;
    }

    /// <summary>
    /// Removes a list of strings from a string.
    /// </summary>
    public static string Remove(this string value, params string[] toRemove)
    {
        foreach (var str in toRemove)
            value = value.Replace(str, "");

        return value;
    }

    /// <summary>
    /// Replaces all strings according to a map.
    /// </summary>
    public static string ReplaceWithMap(this string value, params KeyValuePair<string, string>[] stringMap)
        => value.ReplaceWithMap(stringMap.ToDictionary());

    /// <summary>
    /// Replaces all strings according to a map.
    /// </summary>
    public static string ReplaceWithMap(this string value, params KeyValuePair<char, string>[] charMap)
        => value.ReplaceWithMap(charMap.ToDictionary());

    /// <summary>
    /// Replaces all strings according to a map.
    /// </summary>
    public static string ReplaceWithMap(this string value, params KeyValuePair<char, char>[] charMap)
        => value.ReplaceWithMap(charMap.ToDictionary());

    /// <summary>
    /// Replaces all strings according to a map.
    /// </summary>
    public static string ReplaceWithMap(this string value, IDictionary<char, string> charMap)
    {
        foreach (var pair in charMap)
            value = value.Replace(pair.Key.ToString(), pair.Value);

        return value;
    }

    /// <summary>
    /// Replaces all strings according to a map.
    /// </summary>
    public static string ReplaceWithMap(this string value, IDictionary<char, char> charMap)
    {
        foreach (var pair in charMap)
            value = value.Replace(pair.Key, pair.Value);

        return value;
    }

    /// <summary>
    /// Replaces all strings according to a map.
    /// </summary>
    public static string ReplaceWithMap(this string value, IDictionary<string, string> stringMap)
    {
        foreach (var pair in stringMap)
            value = value.Replace(pair.Key, pair.Value);

        return value;
    }

    /// <summary>
    /// Checks whether or not a string is similar to another string using Levenhstein distance.
    /// </summary>
    public static bool IsSimilar(this string source, string target, double minScore = 0.9)
        => source.GetSimilarity(target) >= minScore;

    /// <summary>
    /// Gets the similarity of a string to another string.
    /// </summary>
    public static double GetSimilarity(this string source, string target)
    {
        if (string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(target))
            return 0.0;

        if (source == target)
            return 1.0;

        var stepsToSame = GetLevenshteinDistance(source, target);

        return (1.0 - ((double)stepsToSame / (double)Math.Max(source.Length, target.Length)));
    }

    /// <summary>
    /// Gets the distance of a string to another string.
    /// </summary>
    public static int GetLevenshteinDistance(this string source, string target)
    {
        if (string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(target))
            return 0;

        if (source == target)
            return source.Length;

        var sourceWordCount = source.Length;
        var targetWordCount = target.Length;

        if (sourceWordCount == 0)
            return targetWordCount;

        if (targetWordCount == 0)
            return sourceWordCount;

        var distance = new int[sourceWordCount + 1, targetWordCount + 1];

        for (int i = 0; i <= sourceWordCount; distance[i, 0] = i++) ;
        for (int j = 0; j <= targetWordCount; distance[0, j] = j++) ;
        for (int i = 1; i <= sourceWordCount; i++)
        {
            for (int j = 1; j <= targetWordCount; j++)
            {
                var cost = (target[j - 1] == source[i - 1]) ? 0 : 1;

                distance[i, j] = Math.Min(Math.Min(distance[i - 1, j] + 1, distance[i, j - 1] + 1), distance[i - 1, j - 1] + cost);
            }
        }

        return distance[sourceWordCount, targetWordCount];
    }

    /// <summary>
    /// Removes all whitespaces in a string.
    /// </summary>
    public static string FilterWhiteSpaces(this string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return input;

        var builder = StringBuilderPool.Shared.Rent();

        for (int i = 0; i < input.Length; i++)
        {
            var c = input[i];

            if (i == 0 || c != ' ' || (c == ' ' && input[i - 1] != ' '))
                builder.Append(c);
        }

        return StringBuilderPool.Shared.ToStringReturn(builder);
    }

    /// <summary>
    /// Attempts to split a string.
    /// </summary>
    public static bool TrySplit(this string line, char splitChar, bool removeEmptyOrWhitespace, int? length, out string[] splits)
    {
        splits = line.Split(splitChar).Select(str => str.Trim()).ToArray();

        if (removeEmptyOrWhitespace)
            splits = splits.Where(str => !string.IsNullOrWhiteSpace(str)).ToArray();

        if (length.HasValue && splits.Length != length)
            return false;

        return splits.Any();
    }

    /// <summary>
    /// Attempts to split a string.
    /// </summary>
    public static bool TrySplit(this string line, char[] splitChars, bool removeEmptyOrWhitespace, int? length, out string[] splits)
    {
        splits = line.Split(splitChars).Select(str => str.Trim()).ToArray();

        if (removeEmptyOrWhitespace)
            splits = splits.Where(str => !string.IsNullOrWhiteSpace(str)).ToArray();

        if (length.HasValue && splits.Length != length)
            return false;

        return splits.Any();
    }

    /// <summary>
    /// Formats a collection to a string.
    /// </summary>
    public static string AsString(this IEnumerable<string> values, string separator = "\n")
        => string.Join(separator, values);

    /// <summary>
    /// Formats a collection to a string.
    /// </summary>
    public static string AsString<T>(this IEnumerable<T> values, Func<T, string> convertor, string separator = "\n")
        => string.Join(separator, values.Select(x => convertor(x)));

    /// <summary>
    /// Formats a collection to a string.
    /// </summary>
    public static string AsString<T>(this IEnumerable<T> values, Func<T, string> convertor, Predicate<T> predicate, string separator = "\n")
        => string.Join(separator, values.Where(x => predicate(x)).Select(x => convertor(x)));

    /// <summary>
    /// Retrieves a substring and appends a postfix string.
    /// </summary>
    public static string SubstringPostfix(this string str, int index, int length, string postfix = " ...")
        => str.Substring(index, length) + postfix;

    /// <summary>
    /// Retrieves a substring and appends a postfix string.
    /// </summary>
    public static string SubstringPostfix(this string str, int length, string postfix = " ...")
        => str.SubstringPostfix(0, length, postfix);

    /// <summary>
    /// Gets all characters in a string before a specific index.
    /// </summary>
    public static string GetBefore(this string input, char c)
    {
        var start = input.IndexOf(c);

        if (start > 0)
            input = input.Substring(0, start);

        return input;
    }

    /// <summary>
    /// Gets all characters in a string after a specific index.
    /// </summary>
    public static string GetAfter(this string input, char c)
    {
        var start = input.IndexOf(c);

        if (start > 0)
            input = input.Substring(start, input.Length - start);

        return input;
    }

    /// <summary>
    /// Removes brackets at the end of a string.
    /// </summary>
    public static string RemoveBracketsOnEndOfName(this string name)
    {
        int bracketStart = name.IndexOf('(') - 1;

        if (bracketStart > 0)
            name = name.Remove(bracketStart, name.Length - bracketStart);

        return name;
    }

    /// <summary>
    /// Converts a string to snake case.
    /// </summary>
    public static string SnakeCase(this string str)
    {
        if (str is null)
            throw new ArgumentNullException(nameof(str));

        if (str.Length <= 1)
            return str;

        var sb = StringBuilderPool.Shared.Rent();

        sb.Append(char.ToLowerInvariant(str[0]));

        for (int i = 0; i < str.Length; i++)
        {
            if (char.IsUpper(str[i]))
                sb.Append('_').Append(char.ToLowerInvariant(str[i]));
            else
                sb.Append(str[i]);
        }

        return StringBuilderPool.Shared.ToStringReturn(sb);
    }

    /// <summary>
    /// Converts a string to camel case.
    /// </summary>
    public static string CamelCase(this string str)
    {
        str = str.Replace("_", "");

        if (str.Length == 0)
            return "null";

        str = CamelCaseRegex.Replace(str, match => match.Groups[1].Value + match.Groups[2].Value.ToLower() + match.Groups[3].Value);

        return char.ToLower(str[0]) + str.Substring(1);
    }

    /// <summary>
    /// Converts a string to pascal case.
    /// </summary>
    public static string PascalCase(this string str)
    {
        str = str.CamelCase();
        return char.ToUpper(str[0]) + str.Substring(1);
    }

    /// <summary>
    /// Converts a string to title case.
    /// </summary>
    public static string TitleCase(this string str)
    {
        if (string.IsNullOrWhiteSpace(str))
            return str;

        var words = str.Split(' ');

        for (int i = 0; i < words.Length; i++)
        {
            if (words[i].Length <= 0)
                continue;

            var c = char.ToUpper(words[i][0]);
            var str2 = "";

            if (words[i].Length > 1)
                str2 = words[i].Substring(1).ToLower();

            words[i] = c + str2;
        }

        return string.Join(" ", words);
    }

    /// <summary>
    /// Adds spaces by lower case characters.
    /// </summary>
    public static string SpaceByLowerCase(this string str)
    {
        var newStr = "";

        for (int i = 0; i < str.Length; i++)
        {
            if (i == 0)
            {
                newStr += str[i];
                continue;
            }

            if ((i + 1) < str.Length && char.IsLower(str[i + 1]))
            {
                newStr += $" {str[i]}{str[i + 1]}";
                i += 1;
                continue;
            }
        }

        return newStr.Trim();
    }

    /// <summary>
    /// Adds spaces by upper case characters.
    /// </summary>
    public static string SpaceByUpperCase(this string str)
        => PascalCaseRegex.Replace(str, "$1 ");

    /// <summary>
    /// Removes whitespaces at the end of a string.
    /// </summary>
    public static void RemoveTrailingWhiteSpaces(this StringBuilder builder)
    {
        if (builder is null)
            throw new ArgumentNullException(nameof(builder));

        while (builder.Length > 0 && char.IsWhiteSpace(builder[builder.Length - 1]))
            builder.Remove(builder.Length - 1, 1);
    }
}